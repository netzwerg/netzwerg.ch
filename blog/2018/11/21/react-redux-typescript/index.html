<html>
<head>

    <title>Above, Below, and Beyond Tech Talk</title>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="/favicon.png" rel="icon" />

    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/tomorrow-night-bright.css" />

    <link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />

    <link href="/css/style.css" rel="stylesheet" />
</head>
<body>
<div class="container header">
    <div class="jumbotron">
        <h1>Above, Below, and Beyond Tech Talk</h1>
        <p>by Rahel L√ºthy</p>
    </div>
    <nav class="navbar navbar-default">
        <div>
            <ul class="nav navbar-nav">
                <li><a href="/">Blog</a></li>
                <li><a href="/archive.html">Archive</a></li>
                <li><a href="/about.html">About</a></li>
            </ul>
        </div>
    </nav>
</div>
<div class="container content">
    <div class="info">
    November 21, 2018
</div>
<h1>How we use React/Redux with TypeScript</h1>
<p>Our team develops visual applications in the field of medical informatics. We started using React/Redux with TypeScript a few months ago. This post is a highly opinionated summary of best practices that evolved over time:</p>
<ul>
<li><a href="#1">Favor Types Over Classes</a></li>
<li><a href="#2">Don‚Äôt Fear Stringly Types</a></li>
<li><a href="#3">Favor Composition Over Inheritance</a></li>
<li><a href="#4">Immutability FTW</a></li>
<li><a href="#5">Nominal Typing</a></li>
<li><a href="#6">Explicit Types Enhance Readability</a></li>
<li><a href="#7">TSS: CSS + TypeScript = üòç</a></li>
<li><a href="#8">Look Ma, No Semicolons!</a></li>
</ul>
<p>A bit of personal background, to give certain decisions more context: I have been developing user interfaces for over 20 years. Java and OOP have been loyal companions throughout most of this time. A few years ago, I started doing more and more FP, mostly in Scala &amp; Elm, but also in Java (hi <a href="http://www.vavr.io">vavr</a> üëã).</p>
<p>Our team members come from all sorts of backgrounds. When deciding on a web app stack, opinions varied a lot. We finally settled on React/Redux + TypeScript as a compromise ‚Äì it turned out to be a good decision.</p>
<h2 id="favor-types-over-classes"><a name="1"></a>Favor Types Over Classes</h2>
<p>Coming from an OOP background, it was comforting that TypeScript brings familiar OOP constructs to the table. However, TypeScript is based on a structural type system, which can confuse Java developers very quickly:</p>
<pre class="typescript"><code>class Patient {

    firstName: string
    lastName: string

    constructor(firstName: string, lastName: string) {
        this.firstName = firstName
        this.lastName = lastName
    }
}

const patient: Patient = { firstName: 'Ada', lastName: 'Lovelace' }

console.log(patient instanceof Patient) // false ‚Äì seriously?! ü§î</code></pre>
<p>I am sure that one could get used to the TypeScript way of working with classes. However, we somehow ended up not using classes at all ü§∑. Instead, we exclusively model our data with read-only types:</p>
<pre class="typescript"><code>type Patient = Readonly&lt;{
    id: PatientId
    caseId: CaseId
    bed: BedId
    firstName: string
    lastName: string
}&gt;</code></pre>
<p>Super concise and very safe to use.</p>
<h2 id="dont-fear-stringly-types"><a name="2"></a>Don‚Äôt Fear Stringly Types</h2>
<p>Any experienced Java programmer avoids stringly types like the plague. In Java, this makes sense, they prevent the compiler from helping us find errors. The TypeScript compiler works differently, so be ready to embrace patterns which you would avoid in Java:</p>
<pre class="typescript"><code>type Patient = Readonly&lt;{
    gender: 'male' | 'female' | 'non-binary'
}&gt;</code></pre>
<p>Code completion works perfectly fine here:</p>
<p><img src="/images/typescript-code-completion.png" /></p>
<p>And the compiler detects errors flawlessly:</p>
<pre class="typescript"><code>const smartStringHandling = (patient: Patient) =&gt; {
    if (patient.gender === 'whatever') { // compile error
        
    }
}</code></pre>
<p>To give a more advanced example, here‚Äôs how we base our action types, actions, and reducers on simple strings:</p>
<p><em>actionTypes.ts</em></p>
<pre class="typescript"><code>const ADD_MESSAGE = 'message/add'
const ADD_TODO = 'todo/add'</code></pre>
<p><em>actions.ts</em></p>
<pre class="typescript"><code>type Action = AddMessageAction | AddTodoAction

type AddMessageAction = Readonly&lt;{
    type: typeof ADD_MESSAGE
    message: Message
}&gt;

type AddTodoAction = Readonly&lt;{
    type: typeof ADD_TODO
    todo: Todo
}&gt;</code></pre>
<p><em>reducer.ts</em></p>
<pre class="typescript"><code>const reducer = (state: State, action: Action): State =&gt; {
    switch (action.type) {
        case ADD_MESSAGE:

            // üéâ this would require a cast in Java
            const message = action.message

            return {
                ...state,
                messages: state.messages.push(message)
            }
        case ADD_TODO:
            return {
                ...state,
                todos: state.todos.push(action.todo)
            }
    }
}</code></pre>
<h2 id="favor-composition-over-inheritance"><a name="3"></a>Favor Composition Over Inheritance</h2>
<p>As mentioned above, we don‚Äôt really use TypeScript‚Äôs OOP features, so using inheritance has never been very tempting. Instead, we often use a mix of composition, union types, and intersection types to foster code re-use:</p>
<pre class="typescript"><code>type Patient = Readonly&lt;{
    address: Address // Composition
    gender: 'male' | 'female' | 'non-binary' // Union Type
}&gt;

type Displayable = Readonly&lt;{
    displayName: string
}&gt;

type DisplayablePatient = Patient &amp; Displayable // Intersection Type</code></pre>
<h2 id="immutability-ftw"><a name="4"></a>Immutability FTW</h2>
<p>We haven‚Äôt seen many runtime errors, but the ones that occurred were all caused by inconsistent mutations. That‚Äôs why we settled on using the <a href="https://facebook.github.io/immutable-js">immutable</a> collections library to make all our state completely read-only:</p>
<pre class="typescript"><code>import { Map } from 'immutable'

type State = Readonly&lt;{
    bedByPatient: Map&lt;PatientId, BedId&gt;
}&gt;</code></pre>
<h2 id="nominal-typing"><a name="5"></a>Nominal Typing</h2>
<p>Using type aliases for your identifiers seems very convenient. No need for extra wrapping, and very readable code:</p>
<pre class="typescript"><code>type PatientId = string
type BedId = string

type State = Readonly&lt;{
    bedByPatient: Map&lt;PatientId, BedId&gt;
}&gt;</code></pre>
<p>Unfortunately, things look more type-safe than they are. Aliases are nothing more than what their name implies: they are simple synonyms. Any <code>string</code> can be used in place of a <code>PatientId</code> or <code>BedId</code> ‚Äì and vice versa:</p>
<pre class="typescript"><code>
const state: State = {
    bedByPatient: Map&lt;PatientId, BedId&gt;()
}

// Compiles just fine, which is NOT what we want
state.bedByPatient.set('foo', 'bar')</code></pre>
<p>We want to have types which can be distinguished by the compiler because they have different names, even though they share the same structure (a <code>string</code>). This is known as ‚Äúnominal typing‚Äù. The <a href="https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html">TypeScript Deep Dive Book</a> gives a good list of nominal typing patterns.</p>
<p>We are using the <code>enum</code>-based brand pattern to get the desired compile-time safety:</p>
<pre class="typescript"><code>enum PatientIdBrand {}
type PatientId = PatientIdBrand &amp; string

enum BedIdBrand {}
type BedId = BedIdBrand &amp; string

type State = Readonly&lt;{
    bedByPatient: Map&lt;PatientId, BedId&gt;
}&gt;

const state: State = {
    bedByPatient: Map()
}

// Compile error:
// Argument type '&quot;foo&quot;' is not assignable to parameter of type 'PatientId'
state.bedByPatient.set('foo', 'bar')</code></pre>
<h2 id="explicit-types-enhance-readability"><a name="6"></a>Explicit Types Enhance Readability</h2>
<p>While it is often possible to not specify types explicitly, they still sometimes enhance code readability (and IDE completion, for that matter). Container components are a good example: they involve a lot of ‚Äúplumbing‚Äù, where input/output types have to match, so explicit types are a plus here. This is how our container components tend to look:</p>
<pre class="typescript"><code>type Props = Readonly&lt;{
    patientId: PatientId
}&gt;

type FromStateProps = Readonly&lt;{
    patient: Patient
}&gt;

const mapStateToProps = (state: State, props: Props): FromStateProps =&gt; {
    const patient = getPatient(state, props.patientId)
    return {
        patient
    }
}

type FromDispatchProps = Readonly&lt;{
    onMouseEnter: () =&gt; void
    onMouseOut: () =&gt; void
}&gt;

const mapDispatchToProps = (dispatch: Dispatch&lt;PatientsAction&gt;, props: Props): FromDispatchProps =&gt; {
    return {
        onMouseEnter: () =&gt; dispatch(selectPatients(ImmutableList.of(props.patientId))),
        onMouseOut: () =&gt; dispatch(selectPatients(ImmutableList()))
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(ExampleComponent)</code></pre>
<h2 id="tss-css-typescript"><a name="7"></a>TSS: CSS + TypeScript = üòç</h2>
<p>As a developer, CSS has always been the scary corner of my applications. It uses a global namespace, you cannot use variables, and it‚Äôs almost impossible to tell which code is even in use at all. So you end up treating your CSS very differently from the rest of your code: no refactorings, no re-use, no clean-up.</p>
<p>We are using <a href="https://material-ui.com">Material-UI</a> in all our projects, so it did not take much convincing to also use their styling solution. It uses JSS at its core and has excellent TypeScript support. This is how a basic component looks:</p>
<pre class="typescript"><code>import { createStyles, withStyles, WithStyles } from '@material-ui/core'
import * as React from 'react'

const styles = createStyles({
    root: {
        backgroundColor: 'steelblue'
    }
})

type Props = Readonly&lt;{
    text: string
}&gt; &amp; WithStyles&lt;typeof styles&gt;

const ExampleComponent = ({ text, classes }: Props) =&gt;
    &lt;div className={classes.root}&gt;{text}&lt;/div&gt;

export default withStyles(styles)(ExampleComponent)</code></pre>
<h2 id="look-ma-no-semicolons"><a name="8"></a>Look Ma, No Semicolons!</h2>
<p>And finally, a good practice that is not specific to React nor TypeScript: make your code <a href="https://prettier.io">prettier</a>! We use <a href="https://github.com/typicode/husky">husky</a> to kick off code formatting before each git commit. Here‚Äôs our current configuration:</p>
<p><em>.prettierrc:</em></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb15-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">&quot;tabWidth&quot;</span><span class="fu">:</span> <span class="dv">4</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="dt">&quot;useTabs&quot;</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="dt">&quot;semi&quot;</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="dt">&quot;singleQuote&quot;</span><span class="fu">:</span> <span class="kw">true</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="dt">&quot;printWidth&quot;</span><span class="fu">:</span> <span class="dv">120</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="fu">}</span></a></code></pre></div>
<p><em>Thanks for reviewing this post, <a href="https://twitter.com/ben_rosenbaum">Ben</a>!</em></p>

</div>
<div class="container footer">
    <p>Written by Rahel L√ºthy &mdash; Generated by <a href="https://jaspervdj.be/hakyll">Hakyll</a></p>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>