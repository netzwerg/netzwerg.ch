<html>
<head>

    <title>Above, Below, and Beyond Tech Talk</title>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="/favicon.png" rel="icon" />

    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/tomorrow-night-bright.css" />

    <link href="https://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />

    <link href="/css/style.css" rel="stylesheet" />
</head>
<body>
<div class="container header">
    <div class="jumbotron">
        <h1>Above, Below, and Beyond Tech Talk</h1>
        <p>by Rahel Lüthy</p>
    </div>
    <nav class="navbar navbar-default">
        <div>
            <ul class="nav navbar-nav">
                <li><a href="/">Blog</a></li>
                <li><a href="/archive.html">Archive</a></li>
                <li><a href="/about.html">About</a></li>
            </ul>
        </div>
    </nav>
</div>
<div class="container content">
    <div class="info">
    April 24, 2018 
</div>
<h1>Position animations across SVG groups</h1>
<p>Animated transitions between UI states can greatly enhance the usability of applications because they reduce the likelihood of <a href="https://en.wikipedia.org/wiki/Change_blindness">change blindness</a>.</p>
<p>In a typical web application, UI state is represented by the DOM. Instead of switching from one DOM state to the next instantaneously, animations smoothly transition DOM element properties over time.</p>
<p>On a technical level, a multitude of libraries provide abstractions to create animated transitions with minimal effort.</p>
This is how an animation of an SVG circle would look like with D3.js (notice the “Rerun” button which appears once you hover the right pane):<br />
 
<p data-height="265" data-theme-id="0" data-slug-hash="JvXobe" data-default-tab="js,result" data-user="netzwerg" data-embed-version="2" data-pen-title="D3.js Animation" class="codepen">
See the Pen <a href="https://codepen.io/netzwerg/pen/JvXobe/">D3.js Animation</a> by Rahel Lüthy (<a href="https://codepen.io/netzwerg"><span class="citation" data-cites="netzwerg">@netzwerg</span></a>) on <a href="https://codepen.io">CodePen</a>.
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>
<p><br />
 </p>
<p>D3.js is interpolating the circle’s <code>cx</code> attribute from <code>10</code> to <code>190</code> pixels over the course of a second.</p>
<p>Well, this is a simple example because the SVG scene graph is simple – it just contains one circle. Unfortunately, SVG scene graphs tend to get very complex in real applications. One way to tame this complexity, is by breaking applications into components, each responsible for rendering a sub-graph of the final SVG.</p>
<h2 id="components-ftw">Components FTW</h2>
<p>Component-based libraries like React come in handy here: Each component is responsible for rendering a small, human-digestible SVG chunk.</p>
<p>Here’s a React component which renders a box with a circle at its center:</p>
<p><img src="/images/box-static-circle.png" width="25%" style="padding: 20 0 20 0;" /></p>
<pre class="typescript"><code>const Box = ({width, height}: BoxProps) =&gt; {
    return (
        &lt;g&gt;
            &lt;rect width={width} height={height}/&gt;
            &lt;circle cx={width / 2} cy={height / 2}/&gt;
        &lt;/g&gt;
    );
};</code></pre>
<p>Using simple composition, we can then stack two boxes on top of each other:</p>
<p><img src="/images/boxes-static-circle.png" width="25%" style="padding: 20 0 20 0;" /></p>
<pre class="typescript"><code>&lt;g&gt;
    &lt;Box width={width} height={height / 2} /&gt;
&lt;/g&gt;
&lt;g transform={`translate(0,${height / 2})`}&gt;
    &lt;Box width={width} height={height / 2} /&gt;
&lt;/g&gt;</code></pre>
<p>Note how the second box gets moved to the bottom by translating its container group by <code>height/2</code>.</p>
<p>To make things a bit more interesting, let’s make the circle alternate between boxes at a fixed interval:</p>
<p><img src="/images/boxes-jumping-circle.gif" width="25%" style="padding: 20 0 20 0;" /></p>
<pre class="typescript"><code>type State = {
    readonly box: 'UPPER' | 'LOWER';
};

class App extends React.Component&lt;object, State&gt; {

    private readonly circleId = 'circleId';
    private timer: Timer;

    constructor(props: object) {
        super(props);
        this.state = {box: 'UPPER'};
    }

    componentDidMount() {
        this.timer = setInterval(() =&gt; this.switchBox(), 1000);
    }

    switchBox() {
        this.setState(prevState =&gt; ({box: prevState.box === 'UPPER' ? 'LOWER' : 'UPPER'}));
    }

    render() {

        const viewBox = {width: 100, height: 100};
        const margin = {top: 10, right: 10, bottom: 10, left: 10};
        const width = viewBox.width - margin.left - margin.right;
        const height = viewBox.height - margin.top - margin.bottom;

        return (
            &lt;div className=&quot;App&quot;&gt;
                &lt;svg viewBox={`0 0 ${viewBox.width} ${viewBox.height}`}&gt;
                    &lt;g transform={`translate(${margin.left}, ${margin.top})`}&gt;
                        &lt;g&gt;
                            &lt;Box
                                circleId={this.circleId}
                                showCircle={this.state.box === 'UPPER'}
                                width={width}
                                height={height / 2}
                            /&gt;
                        &lt;/g&gt;
                        &lt;g transform={`translate(0,${height / 2})`}&gt;
                            &lt;Box
                                circleId={this.circleId}
                                showCircle={this.state.box === 'LOWER'}
                                width={width}
                                height={height / 2}
                            /&gt;
                        &lt;/g&gt;
                    &lt;/g&gt;
                &lt;/svg&gt;
            &lt;/div&gt;
        );
    }

    componentWillUnmount() {
        clearInterval(this.timer);
    }

}</code></pre>
<p><em>Complete code on <a href="https://github.com/netzwerg/react-animation-demo">GitHub</a></em></p>
<h2 id="smoothly-moving-circles">Smoothly Moving Circles</h2>
<p>Blinking UIs are almost never a good idea, so back to animations! Smoothly moving the circle between boxes looks way better:</p>
<p><img src="/images/boxes-animated-circle.gif" width="25%" style="padding: 20 0 20 0;" /></p>
<p>We already know how to animate a circle’s position with D3.js, so <strong>this should be simple, right</strong>?</p>
<p>Well… the circle’s y-coordinate in the upper box is <code>height/2</code>, and its coordinate in the lower box is <code>height/2</code>, too! So how are we supposed to animate between these identical states?!</p>
<p>I vividly remember my own confusion when I first encountered this problem in one of our research projects.</p>
<p>The complexity is caused by the fact that our components all use their own, 0-based coordinate system. But that’s exactly what made the components simple in the first place, so we don’t want to give this up!</p>
<h2 id="animations-across-component-boundaries">Animations Across Component Boundaries</h2>
<p>Situation recap:</p>
<p><strong>What we have</strong> (and want to keep): <em>Simple components with 0-based coordinate systems</em></p>
<p><strong>What we want</strong>: <em>Animations across component boundaries</em></p>
<p>There’s no easy fix, but we know that animations are simple as long as they are happening on a <strong>common coordinate system</strong>. Thus the idea is straightforward: We keep using 0-based components, but switch to a common coordinate system while performing an animation. One very suitable common coordinate system is the view port coordinate system of our SVG’s root node.</p>
<p>Here’s the rough recipe:</p>
<ul>
<li>Calculate the circle’s global coordinates (relative to the svg view port)</li>
<li>Create a dedicated clone of the circle to be used for the animation</li>
<li>Attach the clone to the SVG root element</li>
<li>Hide the original circle during the course of the animation (so only the clone is visible)</li>
<li><strong>Animate!</strong></li>
<li>Detach the clone once the animation is done</li>
<li>Un-hide the original circle at the final state</li>
</ul>
<p>And in code (remember, the complete project is on <a href="https://github.com/netzwerg/react-animation-demo">GitHub</a>):</p>
<pre class="typescript"><code>const circle = this.svgRoot.getElementById(this.circleId) as SVGCircleElement;

if (circle) {

    // (0) Calculate current coordinates relative to global view port
    const currentCoordinates = this.getCoordinates(this.svgRoot, circle);

    const previousCoordinates = this.coordinateCache || currentCoordinates;

    this.coordinateCache = currentCoordinates;

    const easingFunction = currentCoordinates.cy &gt; previousCoordinates.cy ? easeBounceOut : easeCubicInOut;

    // (1) This clone will be used for the animation
    const animatedCircle = circle.cloneNode(true) as SVGCircleElement;

    // (2) Attach to root element (animated x/y coordinates are in the system of the global view port)
    this.svgRoot.appendChild(animatedCircle);

    // (3) The DOM already contains the circle at the new position -&gt; hide it until the animation is over
    select(circle)
        .attr('visibility', 'hidden');

    // (4) The actual animation
    select(animatedCircle)
        .attr('visibility', 'visible')
        .attr('cx', previousCoordinates.cx)
        .attr('cy', previousCoordinates.cy)
        .transition()
        .duration(1000)
        .ease(easingFunction)
        .attr('cx', currentCoordinates.cx)
        .attr('cy', currentCoordinates.cy)
        .remove() // (5) Detach the animated circle once we're done
        .on('end', () =&gt; { // (6) Un-hide new state (already properly placed in the DOM)
            select(circle)
                .attr('visibility', 'visible');
        });

}</code></pre>
<p>Phew, some things are harder than they should be – let me know if there’s a simpler way!</p>

</div>
<div class="container footer">
    <p>Written by Rahel Lüthy &mdash; Generated by <a href="https://jaspervdj.be/hakyll">Hakyll</a></p>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>