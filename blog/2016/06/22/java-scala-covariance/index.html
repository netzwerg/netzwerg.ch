<html>
<head>

    <title>Above, Below, and Beyond Tech Talk</title>

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link href="/favicon.png" rel="icon" />

    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/tomorrow-night-bright.css" />

    <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />
    <link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css" />

    <link href="/css/style.css" rel="stylesheet" />
</head>
<body>
<div class="container header">
    <div class="jumbotron">
        <h1>Above, Below, and Beyond Tech Talk</h1>
        <p>by Rahel Lüthy</p>
    </div>
    <nav class="navbar navbar-default">
        <div>
            <ul class="nav navbar-nav">
                <li><a href="/">Blog</a></li>
                <li><a href="/archive.html">Archive</a></li>
                <li><a href="/about.html">About</a></li>
            </ul>
        </div>
    </nav>
</div>
<div class="container content">
    <div class="info">
    June 22, 2016
</div>
<h1>Covariance in Java and Scala</h1>
<p>While there are tons of articles explaining the concept of covariance in Java, this post attempts to highlight how and why Java and Scala differ when it comes to collection type safety.</p>
<h2 id="java-arrays">Java Arrays</h2>
<p>Let’s start with Java arrays. They are covariant, meaning that an array of type <code>S[]</code> is a subtype of an array of type <code>T[]</code> if <code>S</code> is a subtype of <code>T</code>:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Cat[] cats = { <span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Gizmo&quot;</span>), <span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Bella&quot;</span>) };
Animal[] animals = cats;</code></pre></div>
<p>Things are simple and life is good. The fact that arrays are covariant makes code re-use possible. Utility methods inside <code>java.util.Arrays</code> are perfect examples, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">binarySearch</span>(Object[] a, Object key) {
  <span class="co">// ...</span>
}
<span class="fu">binarySearch</span>(<span class="kw">new</span> Integer[]{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>}, <span class="dv">2</span>); <span class="co">// VALID</span></code></pre></div>
<p>As usual, everything falls apart because of mutability. Java arrays are mutable, making it possible to store the wrong type of object into an array without the compiler being able to tell:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">Cat[] cats = { <span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Gizmo&quot;</span>), <span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Bella&quot;</span>) };
Animal[] animals = cats;
animals[<span class="dv">0</span>] = <span class="kw">new</span> <span class="fu">Dog</span>(<span class="st">&quot;Max&quot;</span>); <span class="co">// FAILS AT RUNTIME</span></code></pre></div>
<p>Ouch, heap pollution – an <code>ArrayStoreException</code> is thrown at runtime! People obsessed with types tend to call this <em>unsound</em>.</p>
<h2 id="java-generics">Java Generics</h2>
<p>With Java 5 came generics, which allow “a type or method to operate on objects of various types while providing compile-time type safety.” (<a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/">Oracle Java 1.5 Docs</a>). Let me repeat that: Generics were introduced to improve <em>type safety</em>. It was thus not an option to accept the same unsound array behavior. Because Java collections are mutable, the only option was to make a <code>List&lt;T&gt;</code> invariant:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">List&lt;Cat&gt; cats = Arrays.<span class="fu">asList</span>(<span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Gizmo&quot;</span>), <span class="kw">new</span> <span class="fu">Cat</span>(<span class="st">&quot;Bella&quot;</span>));
List&lt;Animal&gt; animals = cats; <span class="co">// DOES NOT COMPILE</span></code></pre></div>
<p>Even though <code>Cat</code> is a subtype of <code>Animal</code>, <code>List&lt;Cat&gt;</code> is <em>not</em> a subtype of <code>List&lt;Animal&gt;</code>. This is not very intuitive, but it is necessary to prevent heap pollution at runtime.</p>
<p>Obviously, we still want to write re-usable utility code. <a href="http://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html">Wildcards</a> are making that possible. Methods inside <code>java.util.Collections</code> are good examples, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; <span class="dt">int</span> <span class="fu">binarySearch</span>(List&lt;? <span class="kw">extends</span> Comparable&lt;? <span class="kw">super</span> T&gt;&gt; list, T key) {
  <span class="co">// ...</span>
}</code></pre></div>
<p>In Java, you thus get better compile-time safety when using generified collections than when using raw arrays.</p>
<h2 id="scala-arrays">Scala Arrays</h2>
<p>In Scala, things are a lot different. <code>Array[T]</code> is Scala’s representation for Java’s <code>T[]</code>. Like in Java, a Scala <code>Array</code> is mutable. But in contrast to Java, Scala cares a lot more about compile-time type safety. The only way to prevent unsound heap pollution is to make <code>Array[T]</code> invariant:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> cats: Array[Cat] = Array(<span class="fu">Cat</span>(<span class="st">&quot;Gizmo&quot;</span>), <span class="fu">Cat</span>(<span class="st">&quot;Bella&quot;</span>))
<span class="kw">val</span> animals: Array[Animal] = cats <span class="co">// DOES NOT COMPILE</span></code></pre></div>
<p>Scala arrays are thus safer to use than Java arrays.</p>
<h2 id="scala-list">Scala List</h2>
<p>Things are even better for Scala <code>List</code>, which is immutable. It is thus perfectly safe to make <code>List[+T]</code> covariant (notice the little <code>+</code>). There’s just no way to ever sneak in an object, let alone sneaking in an object with the wrong type:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> cats: List[Cat] = List(<span class="fu">Cat</span>(<span class="st">&quot;Gizmo&quot;</span>), <span class="fu">Cat</span>(<span class="st">&quot;Bella&quot;</span>))
<span class="kw">val</span> animals: List[Animal] = cats <span class="co">// VALID</span></code></pre></div>
<p>In other words: In Scala, <code>List[S]</code> is a subtype of <code>List[T]</code> if <code>S</code> is a subtype of <code>T</code>.</p>

</div>
<div class="container footer">
    <p>Written by Rahel Lüthy &mdash; Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a></p>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-708448-1', 'auto');
    ga('send', 'pageview');

</script>
</body>
</html>